#!/usr/bin/env python
# coding=utf8

"""
====================================
 :mod:`render` Render
====================================
.. moduleauthor:: Daewoo Kim
.. note:: note...

설명
=====

For rendering on canvas, transfer data to canvas by socket
"""
import json
import socket
from threading import Thread
import time
from envs.config_env import Flags_e
from Queue import Queue

import logging
logger = logging.getLogger('Simsim.render')

INIT = 0
PAUSE = 1
PLAY = 2
FF = 3

class Render(Thread):
    def __init__(self):
        Thread.__init__(self)

        self._host = ""
        self._port = Flags_e.port
        self._conn = None
        self.running = True
        self._state = INIT
        self._pause_queue = Queue()

        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.s.bind((self._host, self._port))

    def run(self):
        while self.running:
            self.s.listen(1)
            self._conn, addr = self.s.accept()  # 접속 승인
            print self._conn, addr
            logger.debug("Connected by " + str(addr))
            print ("Connected by " + str(addr))
            while True:
                data = self._conn.recv(1024)
                if not data:
                    logger.info("Disconnect")
                    break
                print data
                if data == "pause":
                    self._state = PAUSE
                elif data == "play":
                    self._state = PLAY
                    self._pause_queue.put("play")
                elif data == "ff":
                    self._state = FF
                    self._pause_queue.put("ff")

    def render(self, world):
        if self._conn is None:
            logger.debug("Not connected")
            return

        if self._state == PLAY:
            time.sleep(0.1)
        elif self._state == PAUSE:
            print self._pause_queue.get()

        update_data = dict()
        drones = world.get_drones()
        for drone in drones:
            drone_data = dict()

            pos = drone.get_position()
            drone_data['x'] = pos[0]
            drone_data['y'] = pos[1]
            drone_data['z'] = pos[2]
            drone_data['a'] = pos[3]

            obs = drone.get_obs()
            drone_data["center"] = (obs['view']['t_x'], obs['view']['t_y'])
            drone_data["size"] = obs['view']['size']

            update_data["drone"+str(drone.id)] = drone_data

        target_position = world.get_target().get_position()
        update_data['target'] = dict()
        update_data['target']["x"] = target_position[0]
        update_data['target']["y"] = target_position[1]
        update_data['target']["z"] = target_position[2]
        update_data['target']["a"] = target_position[3]

        response = self.make_msg("TestServer", "Canvas", "response", "update", update_data)
        i_packet = json.dumps(response)
        try:
            self._conn.send(i_packet)
        except Exception, e:
            logger.info("(render) Network disconnected; " + repr(e))

    def make_msg(self, _src, _dst, _topic, _command, _data):
        # Makes a dict type message
        # Use for only messages generated by Relay

        _payload = dict()
        output = dict()
        output["src"] = _src
        output["dst"] = _dst
        _payload["topic"] = _topic
        _payload["command"] = _command
        _payload["data"] = _data
        output["payload"] = _payload
        return output

    def stop(self):
        self.running = False
        socket.socket(socket.AF_INET,
                      socket.SOCK_STREAM).connect(("localhost", self._port))
        self.s.close()
