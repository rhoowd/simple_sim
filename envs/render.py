#!/usr/bin/env python
# coding=utf8

"""
====================================
 :mod:`render` Render
====================================
.. moduleauthor:: Daewoo Kim
.. note:: note...

설명
=====

For rendering on canvas, transfer data to canvas by socket
"""
import json
import socket
from threading import Thread
import random
from envs.config_env import Flags_e

import logging
logger = logging.getLogger('Simsim.render')


class Render(Thread):
    def __init__(self):
        Thread.__init__(self)

        self._host = ""
        self._port = Flags_e.port
        self._conn = None
        self.running = True

        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.s.bind((self._host, self._port))

    def run(self):
        while self.running:
            self.s.listen(1)
            self._conn, addr = self.s.accept()  # 접속 승인
            print self._conn, addr
            logger.debug("Connected by " + str(addr))
            print ("Connected by " + str(addr))
            while True:
                data = self._conn.recv(1024)
                if not data:
                    logger.info("Disconnect")
                    break
                print data

    def render(self, world):
        if self._conn is None:
            logger.debug("Not connected")
            return

        update_data = dict()
        drones = world.get_drones()
        for drone in drones:
            drone_data = dict()

            pos = drone.get_position()
            drone_data['x'] = pos[0]
            drone_data['y'] = pos[1]
            drone_data['z'] = pos[2]
            drone_data['a'] = pos[3]

            obs = drone.get_obs()
            drone_data["center"] = (obs['t_x'], obs['t_y'])
            drone_data["size"] = obs['size']

            #update_data["drone"+str(drone.id+1)] = drone_data # kwj
            update_data["drone"+str(drone.id)] = drone_data # Drones are now indexed from 0

        target_position = world.get_target().get_position()
        update_data['target'] = dict()
        update_data['target']["x"] = target_position[0]
        update_data['target']["y"] = target_position[1]
        update_data['target']["z"] = target_position[2]
        update_data['target']["a"] = target_position[3]

        response = self.make_msg("TestServer", "Canvas", "response", "update", update_data)
        i_packet = json.dumps(response)
        try:
            self._conn.send(i_packet)
        except Exception, e:
            logger.info("(render) Network disconnected; " + repr(e))

    def send_world(self):
        if self._conn is None:
            logger.debug("Not connected")
            return

        update_data = {}
        drone1 = {}
        drone2 = {}
        drone3 = {}
        target = {}
        drone1["x"] = 100
        drone1["y"] = 100
        drone1["z"] = 10 + random.randint(-1, 1)
        drone1["a"] = 245 + random.randint(-5, 5)
        drone1["center"] = (32 + random.randint(-3, 3), 43 + random.randint(-3, 3))
        drone1["size"] = 3 + random.randint(-1, 3)

        drone2["x"] = -100
        drone2["y"] = -100
        drone2["z"] = 10 + random.randint(-1, 1)
        drone2["a"] = 348 + random.randint(-5, 5)
        drone2["center"] = (15 + random.randint(-3, 3), 50 + random.randint(-3, 3))
        drone2["size"] = 3 + random.randint(-1, 3)

        drone3["x"] = 100
        drone3["y"] = -100
        drone3["z"] = 10 + random.randint(-1, 1)
        drone3["a"] = 58 + random.randint(-5, 5)
        drone3["center"] = (9 + random.randint(-3, 3), 23 + random.randint(-3, 3))
        drone3["size"] = 3 + random.randint(-1, 3)

        target["x"] = 0
        target["y"] = 0
        target["z"] = 0
        target["a"] = 0

        update_data["drone1"] = drone1
        update_data["drone2"] = drone2
        update_data["drone3"] = drone3
        update_data["target"] = target

        response = self.make_msg("TestServer", "Canvas", "response", "update", update_data)

        i_packet = json.dumps(response)
        self._conn.send(i_packet)

    def make_msg(self, _src, _dst, _topic, _command, _data):
        # Makes a dict type message
        # Use for only messages generated by Relay

        _payload = dict()
        output = dict()
        output["src"] = _src
        output["dst"] = _dst
        _payload["topic"] = _topic
        _payload["command"] = _command
        _payload["data"] = _data
        output["payload"] = _payload
        return output

    def stop(self):
        self.running = False
        socket.socket(socket.AF_INET,
                      socket.SOCK_STREAM).connect(("localhost", self._port))
        self.s.close()


if __name__ == '__main__':
    import time
    render = Render()
    render.start()
    while True:
        render.send_world()
        time.sleep(0.1)
