#!/usr/bin/env python
# coding=utf8

# Test Server for Simple Simulator
# Kang, Wan Ju
# Dec. 1, 2017


# -----------------------------------------------------------------------
# Purpose of Test Server is to generate json-formatted garbage data
# and send it to Simple Simulator Canvas whenever requested.
# -----------------------------------------------------------------------



import socket
import ConfigParser
from time import sleep
from threading import Thread
import json
from select import select
import random # for garbage data generation

config = ConfigParser.ConfigParser()
config.read("../params.cfg")

num_drones = config.getint("CanvasParams", "num_drones")
HOST = config.get("CanvasParams", "host")
PORT = config.getint("CanvasParams", "port")

class TestServer(Thread):
    def __init__(self):
        self.HOST = HOST                   # Symbolic name meaning all available interfaces
        self.PORT = PORT                # Arbitrary non-privileged port

        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.s.bind((self.HOST, self.PORT))
        self.s.listen(5)
        self.connections = []
        self.pollingList = []
        self.pollingList.append(self.s)

        self.num_drones = num_drones
        
        self.decoder = json.JSONDecoder() # Needed in case received data is concatenated JSON strings
        Thread.__init__(self)

    def make_msg(self, _src, _dst, _topic, _command, _data):
        # Makes a dict type message
        # Use for only messages generated by Relay
        
        _payload = dict()
        output = dict()
        output["src"] = _src
        output["dst"] = _dst
        _payload["topic"] = _topic
        _payload["command"] = _command
        _payload["data"] = _data
        output["payload"] = _payload
        return output

    def find(self, _key, by_id):
        # Performs a find operation.
        # _key: ID or socket
        # by_id: If 1, find by ID. If 0, find by socket.

        # Returns None if there is nothing found.
        # Returns the Socket corresponding to the given Client ID (if find by id)
        # Returns the Client ID corresponding to the given socket (if find by socket)
        
        # Can be used to check if the client is new or returning.

        retval = None

        for client in self.connections:
            if client[by_id%2] == _key:
                retval = client[(by_id-1)%2]
        return retval

    def unicast(self, dst_id, unicast_packet):
        # Returns the number of bytes sent to client dst_id.
        dst = self.find(dst_id, 1)
        if dst == None:
            #self.logger.error("Non-existing destination")
            return -1
        else:
            i_packet = json.dumps(unicast_packet)
            return dst.send(i_packet)
            
    def broadcast(self, src_id, broadcast_packet):
        # Sends broadcast_data to each client, except the client that is requesting the broadcast.

        for connection in self.connections:
            if not connection[1] == src_id: # No need to send the guy requesting the broadcast
                i_packet = json.dumps(broadcast_packet)
                connection[0].send(i_packet)

        return
    
    def run(self):
        try:
            readable, writable, exceptional = select(self.pollingList, [], [])
        except (KeyboardInterrupt, SystemExit):
            raise

        for sock in readable:
            # ------------------------------------------------------------
            # The accepted client must notify the Relay about its ID.
            # All clients must have a fixed ID.
            # ------------------------------------------------------------
            
            # Connection-accepting branch
            if sock == self.s:
                conn, addr = self.s.accept()
                    
                # TestServer is passive. Client tells its (pre-defined) ID to Relay.
                data = conn.recv(1024)
                    
                if data:
                    j_msg = json.loads(data)
                    if "src" in j_msg:
                        if (self.find(j_msg["src"], 1) == None): # Check whether new
                            self.connections.append((conn, j_msg["src"]))
                            self.pollingList.append(conn)
                            print("Connected by " + str(addr) + " " + str(j_msg["src"]))
                                    
                        else:
                            self.pollingList.append(conn)
                            print("Reconnected by " + str(addr) + " " + str(j_msg["src"]))
                    else:
                        print("Unspecified source")



                        
        target = {}
        target["x"] = 0.0
        target["y"] = 0.0
                        
        self.drone_initializers = []
        for i in range(self.num_drones):
            x, y, z, a, center, size = 0.0, 0.0, 20.0, random.randint(0, 360), [64, 64], 400
            
            drone = {}
            drone["x"] = x
            drone["y"] = y
            drone["z"] = z
            drone["a"] = a
            drone["center"] = center
            drone["size"] = size
            self.drone_initializers.append(drone)






            
        while True:
            sleep(0.05)
            update_data = {}

            target["x"] += random.gauss(0.0, 0.2)
            target["y"] += random.gauss(0.0, 0.2)
            target["z"] = 10
            target["a"] = 0
            update_data["target"] = target
            #i = random.randint(0, self.num_drones-1)
            for i in range(len(self.drone_initializers)):
            #for j in range(1):

                self.drone_initializers[i]["x"] += random.uniform(-0.5, 0.5)
                self.drone_initializers[i]["y"] += random.uniform(-0.5, 0.5)
                self.drone_initializers[i]["z"] += random.uniform(-0.5, 0.5)
                if self.drone_initializers[i]["z"] < 2: self.drone_initializers[i]["z"] = 2
                self.drone_initializers[i]["a"] += random.uniform(-5.0, 5.0)
                self.drone_initializers[i]["center"][0] += random.randint(-1, 1)
                self.drone_initializers[i]["center"][1] += random.randint(-1, 1)
                self.drone_initializers[i]["size"] += random.randint(-3, 3)
                if self.drone_initializers[i]["size"] < 2: self.drone_initializers[i]["size"] = 2

                update_data["drone"+str(i)] = self.drone_initializers[i]
                                        
            response = self.make_msg("TestServer", "Canvas", "response", "update", update_data)
            self.unicast("Canvas", response)
                                
        self.s.close()

    def end(self):
        for connection in self.connections:
            connection[0].close()
        self.s.close()


if __name__ == "__main__":
    testserver = TestServer()
    testserver.run()
