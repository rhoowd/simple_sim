#!/usr/bin/env python
# coding=utf8

# Test Server for Simple Simulator
# Kang, Wan Ju
# Dec. 1, 2017


# -----------------------------------------------------------------------
# Purpose of Test Server is to generate json-formatted garbage data
# and send it to Simple Simulator Canvas whenever requested.
# -----------------------------------------------------------------------



import socket
#import time
from threading import Thread
import json
from select import select


import random # for garbage data generation
#import logging
#import config


class TestServer(Thread):
    def __init__(self):
        self.HOST = ''                   # Symbolic name meaning all available interfaces
        self.PORT = 23456                # Arbitrary non-privileged port

        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.s.bind((self.HOST, self.PORT))
        self.s.listen(5)
        self.connections = []
        self.pollingList = []
        self.pollingList.append(self.s)

        self.decoder = json.JSONDecoder() # Needed in case received data is concatenated JSON strings

        Thread.__init__(self)

    def make_msg(self, _src, _dst, _topic, _command, _data):
        # Makes a dict type message
        # Use for only messages generated by Relay
        
        _payload = dict()
        output = dict()
        output["src"] = _src
        output["dst"] = _dst
        _payload["topic"] = _topic
        _payload["command"] = _command
        _payload["data"] = _data
        output["payload"] = _payload
        return output

    def find(self, _key, by_id):
        # Performs a find operation.
        # _key: ID or socket
        # by_id: If 1, find by ID. If 0, find by socket.

        # Returns None if there is nothing found.
        # Returns the Socket corresponding to the given Client ID (if find by id)
        # Returns the Client ID corresponding to the given socket (if find by socket)
        
        # Can be used to check if the client is new or returning.

        retval = None

        for client in self.connections:
            if client[by_id%2] == _key:
                retval = client[(by_id-1)%2]
        return retval

    def unicast(self, dst_id, unicast_packet):
        # Returns the number of bytes sent to client dst_id.
        dst = self.find(dst_id, 1)
        if dst == None:
            #self.logger.error("Non-existing destination")
            return -1
        else:
            i_packet = json.dumps(unicast_packet)
            return dst.send(i_packet)
            
    def broadcast(self, src_id, broadcast_packet):
        # Sends broadcast_data to each client, except the client that is requesting the broadcast.

        for connection in self.connections:
            if not connection[1] == src_id: # No need to send the guy requesting the broadcast
                i_packet = json.dumps(broadcast_packet)
                connection[0].send(i_packet)

        return
    
    def run(self):
        while True:
            try:
                readable, writable, exceptional = select(self.pollingList, [], [])
                for sock in readable:
                    # ------------------------------------------------------------
                    # The accepted client must notify the Relay about its ID.
                    # All clients must have a fixed ID.
                    # ------------------------------------------------------------

                    # Connection-accepting branch
                    if sock == self.s:
                        conn, addr = self.s.accept()
                                                
                        # TestServer is passive. Client tells its (pre-defined) ID to Relay.
                        data = conn.recv(1024)

                        if data:
                            j_msg = json.loads(data)
                            if "src" in j_msg:
                                if (self.find(j_msg["src"], 1) == None): # Check whether new
                                    self.connections.append((conn, j_msg["src"]))
                                    self.pollingList.append(conn)
                                    print("Connected by " + str(addr) + " " + str(j_msg["src"]))
                                    
                                else:
                                    self.pollingList.append(conn)
                                    print("Reconnected by " + str(addr) + " " + str(j_msg["src"]))
                            else:
                                print("Unspecified source")

                    # Data-relaying branch
                    else:
                        data = sock.recv(2048)
                        if data:
                            while data:
                                # Sometimes, the dmgrs might send several messages very fast.
                                # This while loop is needed for processing JSON stream in case several messages are contained in DATA.
                                try:
                                    #print data
                                    j_msg, idx = self.decoder.raw_decode(data)
                                except ValueError:
                                    print("JSON Error")
                                #print(str(j_msg) +"  " +str(idx))

                                # --- Generate json-formatted garbage data and send it to Canvas ---
                                if j_msg:
                                    if j_msg["payload"]["topic"] == "query":
                                        print(j_msg["payload"]["topic"], type(j_msg["payload"]["topic"]))
                                        update_data = {}
                                        drone1 = {}
                                        drone2 = {}
                                        drone3 = {}
                                        target = {}
                                        drone1["x"] = 1277 + random.randint(-5, 5)
                                        drone1["y"] = 987  + random.randint(-5, 5)
                                        drone1["z"] = 10 + random.randint(-1, 1)
                                        drone1["a"] = 245  + random.randint(-5, 5)
                                        drone1["center"] = (32+random.randint(-3, 3), 43+random.randint(-3,3))
                                        drone1["size"] = 3+random.randint(-1, 3)

                                        drone2["x"] = 1432 + random.randint(-5, 5)
                                        drone2["y"] = 1208 + random.randint(-5, 5)
                                        drone2["z"] = 10  + random.randint(-1, 1)
                                        drone2["a"] = 348 + random.randint(-5, 5)
                                        drone2["center"] = (15+random.randint(-3, 3), 50+random.randint(-3,3))
                                        drone2["size"] = 3+random.randint(-1, 3)
                                        
                                        drone3["x"] = 1775 + random.randint(-5, 5)
                                        drone3["y"] = 1309 + random.randint(-5, 5)
                                        drone3["z"] = 10 + random.randint(-1, 1)
                                        drone3["a"] = 58  + random.randint(-5, 5)
                                        drone3["center"] = (9+random.randint(-3, 3), 23+random.randint(-3,3))
                                        drone3["size"] = 3+random.randint(-1, 3)
                                        
                                        target["x"] = 307  + random.randint(-5, 5)
                                        target["y"] = 901  + random.randint(-5, 5)
                                        target["z"] = 0
                                        target["a"] = 0

                                        update_data["drone1"] = drone1
                                        update_data["drone2"] = drone2
                                        update_data["drone3"] = drone3
                                        update_data["target"] = target
                                        
                                        response = self.make_msg("TestServer", "Canvas", "response", "update", update_data)
                                        self.unicast("Canvas", response)
                                
                                # if j_msg:
                                #     if "dst" in j_msg:
                                #         if j_msg["dst"] == "All":
                                #             self.broadcast(j_msg["src"], j_msg)
                                #         else:
                                #             self.unicast(j_msg["dst"], j_msg)
                                #     else:
                                #         self.logger.error("Unspecified destination")
                                data = data[idx:].lstrip()
                        else:
                            # Interpret empty result as closed connection
                            # Notify GCS and Argus that someone disconnected

                            disconnected_client = self.find(sock, 0) # Find the disconnected guy by its socket
                            print disconnected_client, "DISCONNECTED #############################################################"
                            if (disconnected_client != None):
                                j_msg = self.make_msg("Relay", "GCS", "network", "disconnect", disconnected_client)
                                #self.unicast("GCS", j_msg)
                                #self.unicast("Argus", j_msg)

                            # Stop listening for input on the connection
                            self.pollingList.remove(sock)
                            sock.shutdown(2)
                            sock.close()
                                
            except (KeyboardInterrupt, SystemExit):
                raise
        self.s.close()

    def end(self):
        for connection in self.connections:
            connection[0].close()
        self.s.close()


if __name__ == "__main__":
    testserver = TestServer()
    testserver.run()
